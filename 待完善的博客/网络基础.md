## 1. TCP/IP四层



#### 应用层：

应用进程间的交互通信完成特定功能，其协议是根据不同进程应用来决定的，比如域名系统同DNS协议，万维网用HTTP协议，邮件用SMTP协议。应用层交互的数据单元叫做报文，各层数据单元都可叫分组



#### 运输层：

为两台主机进程间通信提供**通用的**传输服务，即传输应用层报文。利用多线程实现复用和分用功能，复用指多个应用进程公用同一运输层，分用指运输层收到的信息交付应用层的相应进程，主要有TCP 和 UDP协议

```
TCP：面向连接，提供可靠字节传输，传输效率相比慢，所需资源也多了，场景使用：文件、邮件、登录
UDP：无连接，提供不可靠数据报文端，传输效率块，所以资源少，场景使用：视频直播

TCP:传输数据前需建立连接，可靠体现在三次握手四次挥手，所以增加了消耗（确认、窗口、重传、拥塞控制机制）
UDP：传输前不需要建立连接，对方收到UDP报文后，不需要应答。但其因为消耗比TCP小，所以视频直播等场景很适用
```



#### 网络层：

提供及时的数据传送，因为通信过程会有多个数据链路，网络层就要选择合适的路由和交换节点，TCP/IP中网络层使用IP协议，所以其分组也叫IP数据包，将运输层的报文段或用户数据封装成分组和包进行传送。



#### 数据链路层：

数据是在分段的链路上传输，这就需要专门的链路层协议，其将网络层的IP数据报封装成帧，其还包括

控制信息（同步、差错检测、地址信息等），控制信息能够知道开始与结束的比特位置，从中提取数据，上交给网络层。控制信息可检测传输差错，若有错即丢弃，以免后面网络传输浪费资源。若需要纠错，则要采用可靠性传输协议。



#### 物理层：

提供比特流的透明传输，透明指经电路传输后比特流没有发生变化，尽可能屏蔽具体传输介质和物理设备的差异，使上层不用考虑其传输介质































ACK：确认号是否有效，（握手后置0）
SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN：希望断开连接

ack：确认号
seq：序列号

大写是标志位，小写是序号













## 2. 三次握手

![1583938430154](C:\Users\Howl\AppData\Roaming\Typora\typora-user-images\1583938430154.png)

**第一次：**

Client：发送syn=1（表示请求连接），seq number=随机

Server：收到syn=1后知道Client要请求连接



**第二次：**

Server：发送ack number = (seq+1)，ack=1，syn=1，seq=随机



**第三次：**

Client：验证ack number是否正确，ack是否为1，然后发送ack number = (seq+1)，ack = 1

Server：验证seq值，ack是否=1，建立连接





#### 为什么需要第三次握手，两次不可以吗？

因为防止失效的请求连接报文传到服务器，这是什么意思呢？假设两次握手的情况：

Client第一次发送连接请求因为网络时延没有到达服务器

然后Client第二次发送请求，这时就成功两次握手并建立连接（假设情况），数据传送完毕断开连接后

原来第一次发送的请求连接这时才到达服务器，服务器收到请求后因为是两次握手，Server直接发送确认报文并建立连接，但此刻Client并没有请求所以不响应，导致资源白白浪费











## 3.四次挥手

![1583942283437](C:\Users\Howl\AppData\Roaming\Typora\typora-user-images\1583942283437.png)

**第一次：**

Client：发送fin=1，seq = u，表示不再发送数据给Server，进入FIN_WAIT_1状态



**第二次：**

Server：收到fin，发送ack = 1，ack=u+1，seq=随机，进入CLOSE_WAIT状态



**第三次：**

Server：发送一个fin=1，ack=1，seq=w，ack=u+1，进入LAST_ACK状态



**第四次：**

Client：收到FIN，ack=seq+1，发送ack=1，ack number =w+1 ，进入TIME_WAIT状态，接着发送ACK给Server，确认序号为收到序号+1

Server：进入CLOSED状态，完成四次挥手





#### 为什么需要四次？

Client请求关闭仅表示自己不会发送数据，Server数据可能还没发完，所以得先发送应答，等数据传完了再发送关闭请求





#### 为什么客户端最后还要等待2MSL

客户端需要保证最后一次发送的ACK报文到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启2MSL计时







## 4. 浏览器输入url回车键发生了什么？

* 域名解析
* TCP连接
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束









## 5. URI /URL

URI：统一资源标志符，可以唯一标识一个资源

URL：在URI下，统一资源定位符，提供具体的地址，当然也是唯一标识一个资源







## 6. 长连接 / 短连接

HTTP/1.0 默认短链接，即每进行一个HTTP操作就建立一次连接，任务结束就关闭连接。当浏览的网页中若带有图片，css，js等其他资源就会重新建立HTTP会话获取



HTTP/1.1默认长连接，即响应头中加入 `Connection:keep-alive`，用于传输HTTP数据的TCP不会打开一个往网页就关闭，当再次访问时会继续用建立的连接，Keep-Alive有一个保持时间







## 7. HTTP / HTTPS

HTTP端口默认：80，其基于TCP上，传输是明文

HTTPS：默认443，其基于SSL/TLS上的HTTP协议，SSL/TLS运行在TCP之上，所有传输内容都是经过加密，适用对称加密，但对称加密的密钥用专门的服务提供方的证书进行非对称加密，所以安全性高，但消耗更多





## 8. HTTPS的SSL/TLS