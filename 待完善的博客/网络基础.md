## 1. TCP/IP四层



#### 应用层：

应用进程间的交互通信完成特定功能，其协议是根据不同进程应用来决定的，比如域名系统同DNS协议，万维网用HTTP协议，邮件用SMTP协议。应用层交互的数据单元叫做报文，各层数据单元都可叫分组



#### 运输层：

为两台主机进程间通信提供**通用的**传输服务，即传输应用层报文。利用多线程实现复用和分用功能，复用指多个应用进程公用同一运输层，分用指运输层收到的信息交付应用层的相应进程，主要有TCP 和 UDP协议

```
TCP：面向连接，提供可靠字节传输，传输效率相比慢，所需资源也多了，场景使用：文件、邮件、登录
UDP：无连接，提供不可靠数据报文端，传输效率块，所以资源少，场景使用：视频直播

TCP:传输数据前需建立连接，可靠体现在三次握手四次挥手，所以增加了消耗（确认、窗口、重传、拥塞控制机制）
UDP：传输前不需要建立连接，对方收到UDP报文后，不需要应答。但其因为消耗比TCP小，所以视频直播等场景很适用
```



#### 网络层：

提供及时的数据传送，因为通信过程会有多个数据链路，网络层就要选择合适的路由和交换节点，TCP/IP中网络层使用IP协议，所以其分组也叫IP数据包，将运输层的报文段或用户数据封装成分组和包进行传送。



#### 数据链路层：

数据是在分段的链路上传输，这就需要专门的链路层协议，其将网络层的IP数据报封装成帧，其还包括

控制信息（同步、差错检测、地址信息等），控制信息能够知道开始与结束的比特位置，从中提取数据，上交给网络层。控制信息可检测传输差错，若有错即丢弃，以免后面网络传输浪费资源。若需要纠错，则要采用可靠性传输协议。



#### 物理层：

提供比特流的透明传输，透明指经电路传输后比特流没有发生变化，尽可能屏蔽具体传输介质和物理设备的差异，使上层不用考虑其传输介质































ACK：确认号是否有效，（握手后置1）
SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN：希望断开连接

ack：确认号
seq：序列号









## 2. 三次握手

![1583938430154](C:\Users\Howl\AppData\Roaming\Typora\typora-user-images\1583938430154.png)

**第一次：**

Client：发送SYN=1，ack=0（表示请求连接），seq number=客户端随机

Server：收到SYN=1后知道Client要请求连接



**第二次：**

Server：发送ack= (对方的seq+1)，ack=1，syn=1，seq=服务器随机



**第三次：**

Client：验证ack是否正确，然后发送ack= (对方seq+1)，ack = 1（并且可以携带数据，前两次不可）

Server：验证seq值，ack是否=1，建立连接





#### 为什么需要第三次握手，两次不可以吗？

原因一：因为防止失效的请求连接报文传到服务器，这是什么意思呢？假设两次握手的情况：

Client第一次发送连接请求因为网络时延没有到达服务器，被认为失效

然后Client第二次发送请求，这时就成功两次握手并建立连接（假设情况），数据传送完毕断开连接后

原来第一次发送的请求连接这时才到达服务器，服务器收到请求后因为是两次握手，Server直接发送确认报文并建立连接，但此刻Client并没有请求所以不响应，导致资源白白浪费



原因二：三次握手才能确保双方序列号被同步，第一次客户端发送自己的随机序列号，第二次服务端确认应答，第三次服务器将自己的随机序列号发送给客户端，第四次客户端确认应答表示收到。由于第二三次可以合并，所以成为了三次握手不是四次









## 3.四次挥手

![1583942283437](C:\Users\Howl\AppData\Roaming\Typora\typora-user-images\1583942283437.png)

**第一次：**

Client：发送Fin=1，seq = c1，表示不再发送数据给Server，进入FIN_WAIT_1状态



**第二次：**

Server：收到Fin，发送ack = 1，ack=c1+1，seq=随机，进入CLOSE_WAIT状态



**第三次：**

Server：发送一个fin=1，ack=1，seq=s3，ack=+1，进入LAST_ACK状态



**第四次：**

Client：收到FIN，ack=seq+1，发送ack=1，ack number =w+1 ，进入TIME_WAIT状态，接着发送ACK给Server，确认序号为收到序号+1

Server：进入CLOSED状态，完成四次挥手



这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**







#### 为什么需要四次？

Client请求关闭仅表示自己不会发送数据，Server数据可能还没发完，所以得先发送应答，等数据传完了再发送关闭请求。客户端请求FIN，服务端确认应答、服务端发送FIN，客户端确认应答。一来一回四次（与握手不同第二三次是分开的）





#### 为什么客户端最后还要等待2MSL

MSL是报文最大生存时间，是从客户端接收到 FIN 后发送 ACK 开始计时的：客户端需要保证最后一次发送的ACK报文到服务器，如果服务器未收到会重发FIN包，这样客户端还有时间再发ACK确认应答，重启2MSL计时。



#### TIME-WAIT状态其存在的原因

其一：保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭

其二：防止已失效的连接请求报文段出现在本连接中。假如客户端发送关闭连接包FIN前服务器有个数据包被延迟了，此时连接已经关闭，然后有个新的连接重新开启，端口等一样则被复用，这次被延迟的数据才到达则会二者不同连接被混乱。出现了TIME-WAIT足以让两个方向上的数据包都被丢弃，则原连接的数据包在网络中都自然消失了，再出现的数据包一定都是新建立连接所产生的





















## 4. 浏览器输入url回车键发生了什么？

* 域名解析
* TCP连接
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束









## 5. URI /URL

URI：统一资源标志符，可以唯一标识一个资源

URL：在URI下，统一资源定位符，提供具体的地址，当然也是唯一标识一个资源







## 6. 长连接 / 短连接

HTTP/1.0 默认短链接，即每进行一个HTTP操作就建立一次连接，任务结束就关闭连接。当浏览的网页中若带有图片，css，js等其他资源就会重新建立HTTP会话获取



HTTP/1.1默认长连接，即响应头中加入 `Connection:keep-alive`，用于传输HTTP数据的TCP不会打开一个往网页就关闭，当再次访问时会继续用建立的连接，Keep-Alive有一个保持时间







## 7. HTTP / HTTPS

HTTP端口默认：80，其基于TCP上，传输是明文

HTTPS：默认443，其基于SSL/TLS上的HTTP协议，SSL/TLS运行在TCP之上，所有传输内容都是经过加密，适用对称加密，但对称加密的密钥用专门的服务提供方的证书进行非对称加密，所以安全性高，但消耗更多





## 8. HTTPS的SSL/TLS