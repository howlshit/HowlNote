> 学习Dubbo需要用到注册中心，前来学习



## 1. 概述

Zookeeper本身是分布式的，其为分布式应用提供**协调服务**的一个Apache项目，常用于注册中心

底层基于观察者模式设计，主要负责存储和管理数据并且接收观察者的注册，数据更新时通知观察者



### 1.1 特点

* 可组成集群：一个Leader，多个Follower
* 集群中半数以上节点存活，Zookeeper集群才能正常服务
* 全局数据一致，集群每个数据内容都一致
* 更新请求顺序进行：来自同一个Client的更新请求按其发送顺序依次执行
* 数据更新原子性
* 实时性：一定时间范围内能读取到最新的数据，也是ZK突出的特点



### 1.2 数据结构

ZK的数据模型和Linux的文件系统类似，整体看成一棵树，每个节点称为ZNode。每一个ZNode默认可存储1MB的数据，每个ZNode通过其路径唯一标识。



节点分为：

* 持久（Persistent），客户端和服务器断开连接，创建的节点不删除
  * 节点不变
  * 节点保留，只是对名称进行顺序编号（分布式中序号可用于推断事件）

* 短暂型（Ephemeral）,客户端和服务器断开连接，创捷的节点自己删除

![1594776498623](C:\Users\Howl\AppData\Roaming\Typora\typora-user-images\1594776498623.png)



### 1.3 应用场景

* 统一命名管理
* 统一配置管理
* 统计集群管理
* 服务器节点动态上下线
* 负载均衡



### 1.4 安装

* [下载](<https://zookeeper.apache.org/>) 安装包并解压
*  修改conf里面的配置，并重命名为`zoo.cfg`

```xml
# 修改数据的存放地址
dataDir=../zkData
```

* 启动ZK（zkServer）
* 启动ZK客户端（zkCli）









## 2. 底层原理



### 2.1 选举机制

其为半数机制，即集群中半数以上存活才有效。虽然配置文件中没有指定Master和Slave，但Leader是通过内部的选举机制临时产生的，其流程如下：



假设5台服务器一个个依次启动：

- 服务器1启动：给自己投票，然后发投票信息。由于没有通信对象，服务器1处于Looking(选举状态)
- 服务器2启动：给自己投票，与之前启动的服务器1交换选举数据，服务器2编号大胜出，但投票数没有大于半数，所以两个服务器的状态依然是LOOKING
- 服务器3启动：给自己投票，与之前启动的服务器1,2交换选举数据，服务器3的编号最大所以服务器3胜出，此时投票数大于半数，所以服务器3成为Leader，服务器1,2成为Slave
- 服务器4启动：给自己投票，与之前启动的服务器1,2,3交换信息，虽然服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为Slave
- 服务器5启动：同理服务器5成为Slave



### 2.2 分布式部署

* 解压安装Zookeeper到各个服务器（hadoop可以同步各个服务器？？）
* 配置每个服务器的编号（myid）

```shell
# 在 /zkData 目录下创建一个myid文件
touch myid

# 往里面添加编号，一个数字即可
1
```

* 配置zoo.cfg文件

```shell
#############Cluster###############
server.2 = 127.0.0.1:22:22
server.3 = 127.0.0.1:23:23
server.4 = 127.0.0.1:24:24
```

* 逐个启动



### 2.3 监听器原理

1. 首先要有一个main()线程
2. 在main线程中创建Zookeeper客户端，内有两个线程，分别负责网络连接(Connect)和监听(Listener)
3. Connect将需要监听的事件发给Zookeeper
4. Zookeeper进行监听事件的注册
5. 发生监听的事件，Zookeeper将消息发送给Listener
6. Listener线程内部调用process()方法



### 2.4 写数据流程

- Client向Zookeeper的follower写数据，那么follower会将请求转发给Leader
- Leader再将请求广播给每个follower，follower写成功后会通知Leader
- Leader收到半数以上的写成功通知后会认为写数据成功，然后通知最初的follower
- 最初的follower会进一步通知Client写数据成功









## 3. 命令

命令比较简单，列出概要自己探索一下即可

```shell
create [-e / -s] /root 123	创建节点

ls	列表

get [watch]	监听

set	修改

delete / rmr	删除节点

quit
```









